# 1) Usando exclusivamente las funciones abordadas en la Lecture 1 # (zeros, ones, hstack y vstack), implementar una funci贸n que cree la # siguiente matriz e imprimir su tama帽o y forma por pantalla:# 1. 1. 0 0 # 1. 1. 0 0 # 0 0 1. 1. # 0 0 1. 1.print("\nEjercicio 1\n")from numpy import zeros from numpy import onesfrom numpy import hstackfrom numpy import vstackz=zeros([2])o=ones([2])zo=hstack([z,o])oz=hstack([o,z])x=vstack([oz,oz,zo,zo])print("Tamao:\n\n",x.shape)print("\nForma:\n\n",x)# 2) Implementar una funci贸n que reciba dos par谩metros enteros (n y m) y # retorne una matriz bidimensional de n煤meros enteros entre 0 y 100 aleatorios # (tip : random). Ejemplo con n=3 y m=2 deber铆a retornar aleatoriamente:# 4 98 # 55 65 # 1 88print("\nEjercicio 2")from numpy import randomn_e2=int(input("Ingresar valor de n: "))m_e2=int(input("Ingresar valor de m: "))def mrand(n,m):    mr=random.randint(100,size=(n,m))    return mrprint("\nMatriz:\n\n",mrand(n_e2,m_e2))# 3) Implementar una funci贸n que reciba dos par谩metros : una matriz # bidimensional de n x m de numeros enteros (tipo de datos ndarray) y un # escalar , y realice manualmente la difusi贸n de la matriz con el escalar.# Manualmente significa que no debe usar la operaci贸n suma de Numpy (entre # ndarray y un escalar) sino que debe recorrer cada uno de los elementos de # la matriz y retornar una nueva matriz sumando enteros al escalar.print("\nEjercicio 3\n")from numpy import array# Se genera matriz con funcin definida en el ejercicio 2A_e3=array([[1, 2, 3],[1, 2, 3]])print("\nMatriz A:\n\n",A_e3)e_e3=int(input("Ingresar valor de e: "))def mdif(A,e):    for i in range(A.shape[0]):        for j in range(A.shape[1]):            A[i,j]+=e    return Aprint("\nMatriz A+e:\n\n",mdif(A_e3,e_e3))# 4) Utilizando las funciones anteriores compare el tiempo ejecucin de su# funcin implementada en el ejercicio anterior con la funcin difusin de # NumPy (Lecture 3.2). Compare los tiempos de ejecucin de cada una para # realizar la suma de una matriz aleatoria con un escalar para matrices de # 10 x10 , 1.000 x 1.000 y 10.000 x 10.000# Tip: para medir el tiempo de ejecucin de una funcin puede usar timeit # de la siguiente forma:# # import timeit as t# # def mifuncion():#     # cdigo de ejemplo#     a=0#     for x in range(10000000):#         a+=1 #     print(a)# # # execution_time = t.timeit(mifuncion, number=1)# print(execution_time)    print("\nEjercicio 4\n")import timeit as t# Se genera matriz con funcin definida en el ejercicio 2A_e4_10x10=mrand(10,10)A_e4_1000x1000=mrand(1000,1000)A_e4_10000x10000=mrand(10000,10000)e_e4=random.randint(1,10)# Funciones (NumPy)def fnum10x10():    a=A_e4_10x10+e_e4    return adef fnum1000x1000():    a=A_e4_1000x1000+e_e4    return adef fnum10000x10000():    a=A_e4_10000x10000+e_e4    return a    # Tiempos de ejecucin (Numpy)mnum10x10=t.timeit(fnum10x10, number=1)mnum1000x1000=t.timeit(fnum1000x1000, number=1)mnum10000x10000=t.timeit(fnum10000x10000, number=1)# Imprimir en pantalla resultados (Numpy)print("Tiempos de ejecucin (Numpy):\n")print(mnum10x10)print(mnum1000x1000)print(mnum10000x10000)# Funciones (Manual)def fman10x10():    a=mdif(A_e4_10x10,e_e4)    return adef fman1000x1000():    a=mdif(A_e4_1000x1000,e_e4)    return adef fman10000x10000():    a=mdif(A_e4_10000x10000,e_e4)    return a# Tiempos de ejecucin (Manual)mman10x10 = t.timeit(fman10x10, number=1)mman1000x1000 = t.timeit(fman1000x1000, number=1)mman10000x10000 = t.timeit(fman10000x10000, number=1)# Imprimir en pantalla resultados (Numpy)print("\nTiempos de ejecucin (Manual):\n")print(mman10x10)print(mman1000x1000)print(mman10000x10000)